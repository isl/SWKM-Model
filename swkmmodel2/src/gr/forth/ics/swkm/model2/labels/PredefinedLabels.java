/* 
 *  COPYRIGHT (c) 2008-2009 by Institute of Computer Science, 
 *  Foundation for Research and Technology - Hellas
 *  Contact: 
 *      POBox 1385, Heraklio Crete, GR-700 13 GREECE
 *      Tel:+30-2810-391632
 *      Fax: +30-2810-391638
 *      E-mail: isl@ics.forth.gr
 *      http://www.ics.forth.gr/isl
 *
 *   Authors  :  Dimitris Andreou, Nelly Vouzoukidou.
 *
 *   This file is part of SWKM model APIs (see also http://athena.ics.forth.gr:9090/SWKM/).
 *
 *    SWKM model APIs is free software: you can redistribute it and/or modify
 *    it under the terms of the GNU Lesser General Public License as published by
 *    the Free Software Foundation, either version 3 of the License, or
 *    (at your option) any later version.
 *
 *   SWKM model APIs is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU Lesser General Public License for more details.
 *
 *   You should have received a copy of the GNU Lesser General Public License
 *   along with SWKM model APIs.  If not, see <http://www.gnu.org/licenses/>.
 * 
 *   SWKM has been partially supported by EU project KP-Lab (IP IST-27490) kp-lab.org
 */


package gr.forth.ics.swkm.model2.labels;

import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Maps;
import com.google.common.collect.Sets;
import gr.forth.ics.swkm.model2.Model;
import gr.forth.ics.swkm.model2.Uri;
import gr.forth.ics.swkm.model2.vocabulary.Rdf;
import gr.forth.ics.swkm.model2.vocabulary.RdfSchema;
import gr.forth.ics.swkm.model2.vocabulary.XmlSchema;
import java.util.Map;
import java.util.Set;

/**
 * An entity that defines predefined labels for particular Resources. This may be used to customize
 * the labels produced by a {@link LabelManager} so that specific nodes will have exactly the
 * required labels, and not labels generated by the labeling algorithm.
 *
 * @author Andreou Dimitris, email: jim.andreou (at) gmail (dot) com
 */
public abstract class PredefinedLabels {
    /**
     * Returns a predefined label of the specified resource, if there is one, or
     * {@code null} otherwise.
     *
     * @param resourceURI the resource URI for which to return a fixed label, if the resource must have
     * a fixed label
     * @return the fixed {@code Label} instance that the resource must have, or {@code null}
     * if the specified resource does not have any fixed label, but the {@link LabelManager} should
     * create a label for it
     */
    public abstract Label predefinedLabelOf(Uri resourceURI);

    /**
     * Returns the resource URIs for which there is a predefined label in this instance.
     *
     * @return the resource URIs for which there is a predefined label in this instance
     */
    public abstract Set<Uri> getResourcesWithPredefinedLabels();

    /**
     * Returns a map with all {@code Uri --> Label} mappings of this instance. Modifying
     * the returned map is a copy and may be modified freely.
     *
     * @return a map with all {@code Uri --> Label} mappings of this instance
     */
    public Map<Uri, Label> toMap() {
        Map<Uri, Label> map = Maps.newHashMap();
        for (Uri resource : getResourcesWithPredefinedLabels()) {
            map.put(resource, predefinedLabelOf(resource));
        }
        return map;
    }

    /**
     * Returns a {@link PredefinedLabels} instance backed by a copy of the provided mapping
     * from URIs to labels.
     * 
     * @param uriToLabelMap a map where each key is a URI and each value the predefined label of
     *      the respective key
     * @return a {@code PredefinedLabels} that represents the specified {@code {URI --> Label}} map
     */
    public static PredefinedLabels fromUriMap(Map<Uri, Label> uriToLabelMap) {
        return new MapBasedPredefinedLabels(uriToLabelMap);
    }

    /**
     * Creates a new {@code PredefinedLabels} by merging this instance with the specified one.
     * In case where a predefined label is defined by both instances for the same URI, the latter is used,
     * i.e. the predefined labels provided as a parameter override the labels of this instance.
     */
    public PredefinedLabels merge(final PredefinedLabels otherPredefinedLabels) {
        Preconditions.checkNotNull(otherPredefinedLabels);
        return new CompositePredefinedLabels(this, otherPredefinedLabels);
    }

    private static final PredefinedLabels swkmPredefinedLabels = PredefinedLabels.fromUriMap(
            ImmutableMap.<Uri, Label>builder()
                .put(RdfSchema.LITERAL, Label.create(12, 12))
                .put(XmlSchema.NOTATION, Label.create(52, 52))
                .put(XmlSchema.NAME, Label.create(58, 58))
                .put(XmlSchema.QNAME, Label.create(51, 51))
                .put(XmlSchema.STRING, Label.create(30, 30))
                .put(XmlSchema.TIME, Label.create(41, 41))
                .put(XmlSchema.TOKEN, Label.create(54, 54))
                .put(XmlSchema.ANY_URI, Label.create(50, 50))
                .put(XmlSchema.BASE64_BINARY, Label.create(49, 49))
                .put(XmlSchema.BOOLEAN, Label.create(33, 33))
                .put(XmlSchema.BYTE, Label.create(70, 70))
                .put(XmlSchema.DATE, Label.create(42, 42))
                .put(XmlSchema.DATETIME, Label.create(34, 34))
                .put(XmlSchema.DECIMAL, Label.create(38, 38))
                .put(XmlSchema.DOUBLE, Label.create(39, 39))
                .put(XmlSchema.DURATION, Label.create(40, 40))
                .put(XmlSchema.FLOAT, Label.create(32, 32))
                .put(XmlSchema.GDAY, Label.create(46, 46))
                .put(XmlSchema.GMONTH, Label.create(47, 47))
                .put(XmlSchema.GMONTH_DAY, Label.create(45, 45))
                .put(XmlSchema.GYEAR, Label.create(44, 44))
                .put(XmlSchema.ENTITIES, Label.create(64, 64))
                .put(XmlSchema.ENTITY, Label.create(63, 63))
                .put(XmlSchema.ID, Label.create(60, 60))
                .put(XmlSchema.IDREF, Label.create(61, 61))
                .put(XmlSchema.IDREFS, Label.create(62, 62))
                .put(XmlSchema.NCNAME, Label.create(59, 59))
                .put(XmlSchema.NMTOKEN, Label.create(56, 56))
                .put(XmlSchema.NMTOKENS, Label.create(57, 57))
                .put(XmlSchema.GYEAR_MONTH, Label.create(43, 43))
                .put(XmlSchema.HEX_BINARY, Label.create(48, 48))
                .put(XmlSchema.INT, Label.create(68, 68))
                .put(XmlSchema.INTEGER, Label.create(31, 31))
                .put(XmlSchema.LANGUAGE, Label.create(55, 55))
                .put(XmlSchema.LONG, Label.create(67, 67))
                .put(XmlSchema.NEGATIVE_INTEGER, Label.create(66, 66))
                .put(XmlSchema.NON_NEGATIVE_INTEGER, Label.create(71, 71))
                .put(XmlSchema.NON_POSITIVE_INTEGER, Label.create(65, 65))
                .put(XmlSchema.NORMALIZED_STRING, Label.create(53, 53))
                .put(XmlSchema.POSITIVE_INTEGER, Label.create(76, 76))
                .put(XmlSchema.SHORT, Label.create(69, 69))
                .put(XmlSchema.UNSIGNED_LONG, Label.create(72, 72))
                .put(XmlSchema.UNSIGNED_INT, Label.create(73, 73))
                .put(XmlSchema.UNSIGNED_SHORT, Label.create(74, 74))
                .put(XmlSchema.UNSIGNED_BYTE, Label.create(75, 75))
                .put(RdfSchema.SUBCLASSOF, Label.create(77, 77))
                .put(RdfSchema.SUBPROPERTYOF, Label.create(78, 78))
                .put(RdfSchema.DOMAIN, Label.create(79, 79))
                .put(RdfSchema.RANGE, Label.create(80, 80))
                .put(Rdf.TYPE, Label.create(81, 81))
                .put(RdfSchema.COMMENT, Label.create(82, 82))
                .put(RdfSchema.LABEL, Label.create(83, 83))
                .put(RdfSchema.SEEALSO, Label.create(84, 84))
                .put(RdfSchema.ISDEFINEDBY, Label.create(85, 85))
                .put(RdfSchema.CLASS, Label.create(300, 1000000000))
                .put(Rdf.PROPERTY, Label.create(2000000001, 2000000000))
                .put(RdfSchema.RESOURCE, Label.create(300, 2000000000))
                .build()
            );

    /**
     * Returns the predefined labels for the SWKM RDF {@link Model model}.
     *
     * @return the predefined labels for the SWKM RDF model
     */
    public static PredefinedLabels swkmPredefinedLabels() {
        return swkmPredefinedLabels;
    }

    private static class MapBasedPredefinedLabels extends PredefinedLabels {
        final Map<Uri, Label> immutablePredefinedLabels;

        public MapBasedPredefinedLabels(Map<Uri, Label> uriToLabelMap) {
            this.immutablePredefinedLabels = ImmutableMap.copyOf(uriToLabelMap);
        }

        @Override
        public Label predefinedLabelOf(Uri resourceUri) {
            return immutablePredefinedLabels.get(resourceUri);
        }

        public Set<Uri> getResourcesWithPredefinedLabels() {
            return immutablePredefinedLabels.keySet();
        }

        @Override
        public String toString() {
            return immutablePredefinedLabels.toString();
        }
    }

    private static class CompositePredefinedLabels extends PredefinedLabels {
        private final PredefinedLabels first;
        private final PredefinedLabels second;

        CompositePredefinedLabels(PredefinedLabels first, PredefinedLabels second) {
            this.first = first;
            this.second = second;
        }

        @Override
        public Label predefinedLabelOf(Uri resourceURI) {
            Label label = second.predefinedLabelOf(resourceURI);
            if (label == null) {
                label = first.predefinedLabelOf(resourceURI);
            }
            return label;
        }

        @Override
        public Set<Uri> getResourcesWithPredefinedLabels() {
            return Sets.union(first.getResourcesWithPredefinedLabels(), second.getResourcesWithPredefinedLabels());
        }

        @Override
        public String toString() {
            return "[" + first + ", " + second + "]";
        }
    }
}
